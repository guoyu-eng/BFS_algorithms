# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/190DUFzfzHqUcgvTImP0VQbORXjNarJYq
"""

from collections import deque

# define the class
class Grid:
    def __init__(self, pixels):
        self.pixels = pixels
        self.width = len(pixels[0])
        self.height = len(pixels)

# check whether is wall
def isWall(grid, x, y):
    if x < 0 or x >= grid.width or y < 0 or y >= grid.height:
        return True
    return grid.pixels[y][x] == 0

def bfs(grid, start_x, start_y, newColor, oldColor):
    queue = deque([(start_x, start_y)])

    while queue:
        x, y = queue.popleft()
        if not (0 <= x < grid.width and 0 <= y < grid.height and grid.pixels[y][x] == oldColor and grid.pixels[y][x] != newColor):
            continue

        grid.pixels[y][x] = newColor

        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:
            nx, ny = x + dx, y + dy
            if not isWall(grid, nx, ny):
                queue.append((nx, ny))

if __name__ == "__main__":
    pixels = [
        [0, 0, 0, 0, 1, 1],
        [1, 1, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 0],
        [1, 1, 0, 1, 1, 1],
        [1, 0, 0, 1, 1, 1]
        # [0,0,0,0,1,1],
        # [1,1,1,1,1,0],
        # [1,1,0,0,1,0],
        # [1,1,0,0,1,1],
        # [1,0,1,1,1,1]
    ]

    grid = Grid(pixels)


    # start point and the color
    start_x, start_y = 5, 0
    target_color = 2
    bfs(grid, start_x, start_y, target_color, grid.pixels[start_y][start_x])
    # print(grid.pixels[0][5])

    for row in grid.pixels:
        print(row)

from collections import deque

class Grid:
    def __init__(self, pixels):
        self.pixels = pixels
        self.width = len(pixels[0])
        self.height = len(pixels)


def bfs(grid, start_x, start_y, target_color, newColor):
    queue = deque([(start_x, start_y)])
    connected_pixels = 0

    while queue:
        x, y = queue.popleft()
        if not (0 <= x < grid.width and 0 <= y < grid.height and grid.pixels[y][x] == target_color):
            continue

        grid.pixels[y][x] = newColor
        connected_pixels += 1

        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < grid.width and 0 <= ny < grid.height and grid.pixels[ny][nx] == target_color:
                queue.append((nx, ny))

    return connected_pixels

if __name__ == "__main__":
    pixels = [
        [0,0,0,0,1,1],
        [1,1,1,1,1,0],
        [1,1,0,0,1,0],
        [1,1,0,0,1,1],
        [1,0,1,1,1,1]

    ]

    grid = Grid(pixels)

    max_connected_component_0 = 0
    max_connected_component_1 = 0

    for y in range(grid.height):
        for x in range(grid.width):
            if grid.pixels[y][x] == 0:
                max_connected_component_0 = max(max_connected_component_0, bfs(grid, x, y, 0, 2))
            elif grid.pixels[y][x] == 1:
                max_connected_component_1 = max(max_connected_component_1, bfs(grid, x, y, 1, 2))

    print("Number of pixels of the largest connected component whose starting point is 0:", max_connected_component_0)
    print("Number of pixels of the largest connected component whose starting point is 1:", max_connected_component_1)








# 

class Matrix:
    def __init__(self, matrix):
        self.matrix = matrix
        self.visited = set()
    def flood_fill(self, start):
        queue = [start]
        while queue:
            current = queue.pop(0)
            self.visited.add(current)
            for neighbor in self.get_neighbors(current):
                if neighbor not in self.visited and self.is_valid(neighbor):
                    queue.append(neighbor)https://github.com/guoyu-eng/BFS_algorithms/blob/main/bfs.py
    def get_neighbors(self, point):
        x, y = point
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        return [(x + dx, y + dy) for dx, dy in directions]

    def is_valid(self, point):
        x, y = point
        return 0 <= x < len(self.matrix) and 0 <= y < len(self.matrix[0]) and self.matrix[x][y] == 0
def main():
    matrix_data = [[1,1,0,0,1,1],
                   [0,1,0,1,1,0],
                   [1,0,0,0,1,0],
                   [0,1,1,0,0,1],
                   [1,0,1,1,1,1]]
    matrix = Matrix(matrix_data)
    matrix.flood_fill((0, 0))
    max_connected_component_size = len(matrix.visited)
    print("Maximum connected component size:", max_connected_component_size)

if __name__ == "__main__":
    main()








